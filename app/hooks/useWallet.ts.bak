'use client';

import { useState, useEffect, useCallback } from 'react';
import { Connection, PublicKey, Transaction } from '@solana/web3.js';

// Types for wallet connection
export interface WalletAdapter {
  publicKey: PublicKey | null;
  connected: boolean;
  connect: () => Promise<void>;
  disconnect: () => Promise<void>;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
  signAllTransactions: (transactions: Transaction[]) => Promise<Transaction[]>;
}

export interface WalletContextType {
  wallet: WalletAdapter | null;
  publicKey: PublicKey | null;
  connected: boolean;
  connecting: boolean;
  connect: () => Promise<void>;
  disconnect: () => Promise<void>;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
  signAllTransactions: (transactions: Transaction[]) => Promise<Transaction[]>;
}

// Solana connection configuration
const SOLANA_RPC_URL = process.env.NEXT_PUBLIC_SOLANA_RPC_URL || 'https://api.devnet.solana.com';
const SOLANA_NETWORK = process.env.NEXT_PUBLIC_SOLANA_NETWORK || 'devnet';

export const useWallet = (): WalletContextType => {
  const [wallet, setWallet] = useState<WalletAdapter | null>(null);
  const [publicKey, setPublicKey] = useState<PublicKey | null>(null);
  const [connected, setConnected] = useState(false);
  const [connecting, setConnecting] = useState(false);

  // Initialize wallet connection
  useEffect(() => {
    const initializeWallet = async () => {
      if (typeof window !== 'undefined' && window.solana && window.solana.isPhantom) {
        const phantomWallet = window.solana;
        
        const walletAdapter: WalletAdapter = {
          publicKey: phantomWallet.publicKey ? new PublicKey(phantomWallet.publicKey.toString()) : null,
          connected: phantomWallet.isConnected,
          connect: async () => {
            try {
              setConnecting(true);
              const response = await phantomWallet.connect();
              setPublicKey(new PublicKey(response.publicKey.toString()));
              setConnected(true);
            } catch (error) {
              console.error('Failed to connect wallet:', error);
              throw error;
            } finally {
              setConnecting(false);
            }
          },
          disconnect: async () => {
            try {
              await phantomWallet.disconnect();
              setPublicKey(null);
              setConnected(false);
            } catch (error) {
              console.error('Failed to disconnect wallet:', error);
              throw error;
            }
          },
          signTransaction: async (transaction: Transaction) => {
            if (!phantomWallet.signTransaction) {
              throw new Error('Wallet does not support signing transactions');
            }
            return await phantomWallet.signTransaction(transaction);
          },
          signAllTransactions: async (transactions: Transaction[]) => {
            if (!phantomWallet.signAllTransactions) {
              throw new Error('Wallet does not support signing multiple transactions');
            }
            return await phantomWallet.signAllTransactions(transactions);
          }
        };

        setWallet(walletAdapter);
        setPublicKey(walletAdapter.publicKey);
        setConnected(walletAdapter.connected);

        // Listen for account changes
        phantomWallet.on('accountChanged', (publicKey: PublicKey | null) => {
          if (publicKey) {
            setPublicKey(new PublicKey(publicKey.toString()));
            setConnected(true);
          } else {
            setPublicKey(null);
            setConnected(false);
          }
        });

        // Listen for disconnect events
        phantomWallet.on('disconnect', () => {
          setPublicKey(null);
          setConnected(false);
        });
      }
    };

    initializeWallet();
  }, []);

  const connect = useCallback(async () => {
    if (!wallet) {
      throw new Error('Wallet not initialized');
    }
    await wallet.connect();
  }, [wallet]);

  const disconnect = useCallback(async () => {
    if (!wallet) {
      throw new Error('Wallet not initialized');
    }
    await wallet.disconnect();
  }, [wallet]);

  const signTransaction = useCallback(async (transaction: Transaction) => {
    if (!wallet) {
      throw new Error('Wallet not initialized');
    }
    return await wallet.signTransaction(transaction);
  }, [wallet]);

  const signAllTransactions = useCallback(async (transactions: Transaction[]) => {
    if (!wallet) {
      throw new Error('Wallet not initialized');
    }
    return await wallet.signAllTransactions(transactions);
  }, [wallet]);

  return {
    wallet,
    publicKey,
    connected,
    connecting,
    connect,
    disconnect,
    signTransaction,
    signAllTransactions
  };
};

// Solana connection helper
export const getSolanaConnection = (): Connection => {
  return new Connection(SOLANA_RPC_URL, 'confirmed');
};

// Declare global window interface for Phantom wallet
declare global {
  interface Window {
    solana?: {
      isPhantom?: boolean;
      isConnected: boolean;
      publicKey: PublicKey | null;
      connect: () => Promise<{ publicKey: PublicKey }>;
      disconnect: () => Promise<void>;
      signTransaction: (transaction: Transaction) => Promise<Transaction>;
      signAllTransactions: (transactions: Transaction[]) => Promise<Transaction[]>;
      on: (event: string, callback: (args: any) => void) => void;
    };
  }
}
